---
title: 参照渡しの注意点
layout: default
parent: トラブルシューティング
grand_parent: AtCoder
---

# 参照渡しを使いまくってたらやらかした

過去にDFSでgraphの情報を値渡しして、関数を走らせまくったらTLEしてしまった。

それから自分の中では、値の変更を行う必要がないものなら参照渡しを使おうという浅はかな考えがあった。　

```cpp
auto& v = que.top(); que.pop(); //同様の状態を簡潔に表現したコード
```

このような記述は大問題である。vはコード実行時にqueのtopに存在した値ではなく、リアルタイムでqueのtopに存在する値となってしまう。

したがって{1, 2, 3}という中身のキューがあったとすると、先ほどコードの直後にvを出力すると2という出力がなされる。(1はpopされ、先頭の要素は2になっているため)

## 関係ないが気になった事案

原因を追求するために以下のようなコードを考えた。

```cpp
min_priority_queue<int> que;
que.push(0);
int cnt = 0;
while(!que.empty()){
    auto& v = que.top(); que.pop();

    cout << v << endl;
    que.push(2);
    cout << v << endl;
    que.push(v);
    cout << v << endl;

    cnt++;
    if(cnt == 20) break;
}
```
参照渡しを使用しているせいで想定とは異なる挙動をしてしまう。

最初の数回の挙動で原因は特定できるため、20回もループを回す必要はないのだが、特定の回数のときに面白い挙動が示された。

2のn乗-1回目のループでキューのサイズが2のn乗+1になったとき、挙動が変化する。

原因は優先度付きキューが平衡二分木を使用していることが関係しているだろう。

コンテナとイテレータの関係はいずれまとめたいと思っているので、そのときにこの挙動の理由を説明できるようになりそう。