---
title: Dijkstraの注意点
layout: default
parent: トラブルシューティング
grand_parent: AtCoder
---
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

# Dijkstra法の注意点

Dijkstra法を使用して問題を解いていたらTLEになってしまった。

最初原因が分からなかったが、原因が分かったため考えた順に記しておく。

## Dijkstra法ではflagを管理しないのか??

BFSやDFSでは探索済みノードを管理するフラグを管理する。

そのフラグを作成していなかったため、フラグを作成しコードが通るかをチェックしてみた。

## flagの位置を間違えた

flagを作成したことにより、TLEは無くすことができた。しかし、ほとんどWA...

BFSやDFSは探索が行われた際に、フラグを変更する必要があるが、キューやスタック(再帰)にノードの情報を挿入する直前に、フラグの変更を行っても問題ない。(探索順とノード挿入順が一致するため)

同様にして、Dijkstraでノード情報を優先度キューに挿入する直前にフラグ変更を行うと、アルゴリズムがうまく動作しなくなる。

理由を簡単に述べると、後に挿入されたノードの優先度が高い場合、先に探索が行われる必要があるのにも関わらず、フラグの変更によってそのノードへのアクセスができなくなる場合が存在するためである。

そのためDijkstraでは、ノードが探索されたタイミングでフラグを変更する必要があることが分かった。

これによってACすることができた。

## あれ、でもそもそもフラグの必要性って

Dijkstra法では、ノードが探索されることと、そのノードの最短経路が確定することが同義である。

実装を見てみると、最短距離ではない場合は弾くように設計している。ここでようやく気づく、最短距離とフラグて同じ意味を持っているのでは??

その推測は正しく、実際に最短距離はフラグの役割を果たしている。ゆえに今回の問題の原因はflagを設計し忘れていたことではないと気づく。

## 辺の重みについて

正直これは一番気をつけていて、大丈夫だと思ってばかりいたが、原因はこいつだった。

今回の問題では与えられる数の制約が\\(10^6\\)だったためintで足りると考えていた、ACが出たときは全てlong longを使用して解いていたときだったが、その後適切な型の使用を試みてintに戻したのだが、実はここが間違いの原因であった。

辺の重みを管理する部分はlong longで設計したため油断していたが、コードの以下のような記述が問題であった。

```cpp
int a, b;
long long w = a * b;
```

過去に何回かやらかしているのに、またやってしまった。a * bはintの領域で計算が行われwにオーバーフローした数値が代入されていた。

つまり、辺の重みに負の値が代入され、無限ループが発生してしまったのが、今回の騒動の原因であった。